; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	C:\Users\Sam\Documents\Visual Studio 2013\Projects\XNA++\Framework\src\TimeSpan.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_GcdX@$0OBA@$0OBA@@std@@2_JB		; std::_GcdX<3600,3600>::value
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_Gx
PUBLIC	?value@?$_Gcd@$0OBA@$0OBA@@std@@2_JB		; std::_Gcd<3600,3600>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_Gx
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_Gy
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_Gy
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?value@?$_Safe_multX@$00$00$00@std@@2_JB	; std::_Safe_multX<1,1,1>::value
PUBLIC	?_Gx@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Lcm<10000000,10000000>::_Gx
PUBLIC	?value@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Lcm<10000000,10000000>::value
PUBLIC	?value@?$_Safe_mult@$00$00@std@@2_JB		; std::_Safe_mult<1,1>::value
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1> >::_N2
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1> >::_D2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_N1
PUBLIC	?value@?$_Is_ratio@U?$ratio@$0OBA@$00@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<3600,1> >::value
PUBLIC	?value@?$_Safe_multX@$00$0JIJGIA@$00@std@@2_JB	; std::_Safe_multX<1,10000000,1>::value
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_D1
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_D2
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_Gx
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_Gy
PUBLIC	?value@?$_Safe_mult@$00$0JIJGIA@@std@@2_JB	; std::_Safe_mult<1,10000000>::value
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,1000> >::value
PUBLIC	?value@?$_Safe_multX@$0JIJGIA@$00$00@std@@2_JB	; std::_Safe_multX<10000000,1,1>::value
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$_Safe_mult@$0JIJGIA@$00@std@@2_JB	; std::_Safe_mult<10000000,1>::value
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?value@?$_Is_ratio@U?$ratio@$0DM@$00@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<60,1> >::value
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,1> >::value
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$_Sign_of@$0DOI@@std@@2_JB		; std::_Sign_of<1000>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?value@?$_Abs@$0DOI@@std@@2_JB			; std::_Abs<1000>::value
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,1>,std::ratio<1,1> >::_N2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,1>,std::ratio<1,1> >::_D2
PUBLIC	?value@?$_GcdX@$0DOI@$00@std@@2_JB		; std::_GcdX<1000,1>::value
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_N1
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_D1
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_N2
PUBLIC	?value@?$_GcdX@$00$0DOI@@std@@2_JB		; std::_GcdX<1,1000>::value
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_D2
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_Gx
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_Gy
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$_Gcd@$00$0DOI@@std@@2_JB		; std::_Gcd<1,1000>::value
PUBLIC	?num@?$ratio@$00$0DOI@@std@@2_JB		; std::ratio<1,1000>::num
PUBLIC	?den@?$ratio@$00$0DOI@@std@@2_JB		; std::ratio<1,1000>::den
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1000> >::_N2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1000> >::_D2
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_N1
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_D1
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?value@?$_Gcd@$0DOI@$00@std@@2_JB		; std::_Gcd<1000,1>::value
PUBLIC	?num@?$ratio@$0DOI@$00@std@@2_JB		; std::ratio<1000,1>::num
PUBLIC	?den@?$ratio@$0DOI@$00@std@@2_JB		; std::ratio<1000,1>::den
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_D2
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_Gx
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?value@?$_Is_duration@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<int,std::ratio<3600,1> > >::value
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?value@?$_GcdX@$0DOI@$0A@@std@@2_JB		; std::_GcdX<1000,0>::value
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0DOI@@std@@2_JB	; std::_GcdX<10000000,1000>::value
PUBLIC	?value@?$_GcdX@$0DOI@$0JIJGIA@@std@@2_JB	; std::_GcdX<1000,10000000>::value
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?value@?$_Gcd@$0DOI@$0JIJGIA@@std@@2_JB		; std::_Gcd<1000,10000000>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_Gy
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?value@?$_Abs@$0CHBA@@std@@2_JB			; std::_Abs<10000>::value
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?value@?$_Sign_of@$0JIJGIA@@std@@2_JB		; std::_Sign_of<10000000>::value
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?value@?$_Safe_multX@$0CHBA@$00$00@std@@2_JB	; std::_Safe_multX<10000,1,1>::value
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Safe_mult@$0CHBA@$00@std@@2_JB	; std::_Safe_mult<10000,1>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1000> > >::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,10000000> >::_N2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,10000000> >::_D2
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sign_of@$0CHBA@@std@@2_JB		; std::_Sign_of<10000>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_N1
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_D1
PUBLIC	?value@?$_GcdX@$0CHBA@$00@std@@2_JB		; std::_GcdX<10000,1>::value
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?value@?$_Gcd@$0JIJGIA@$00@std@@2_JB		; std::_Gcd<10000000,1>::value
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?value@?$_GcdX@$00$0CHBA@@std@@2_JB		; std::_GcdX<1,10000>::value
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?num@?$ratio@$0JIJGIA@$00@std@@2_JB		; std::ratio<10000000,1>::num
PUBLIC	?den@?$ratio@$0JIJGIA@$00@std@@2_JB		; std::ratio<10000000,1>::den
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?value@?$_Gcd@$00$0CHBA@@std@@2_JB		; std::_Gcd<1,10000>::value
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?num@?$ratio@$00$0CHBA@@std@@2_JB		; std::ratio<1,10000>::num
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_N2
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?den@?$ratio@$00$0CHBA@@std@@2_JB		; std::ratio<1,10000>::den
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_D2
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_Gx
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?value@?$_Is_duration@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<int,std::ratio<60,1> > >::value
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_Gy
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,1000>,std::ratio<1,1000> >::_N2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,1000>,std::ratio<1,1000> >::_D2
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_N1
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_D1
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_D2
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_Gx
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB		; std::_GcdX<1000,1000>::value
PUBLIC	?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1> > >::value
PUBLIC	?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB		; std::_Gcd<1000,1000>::value
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_Gy
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?value@?$_Sign_of@$0OBA@@std@@2_JB		; std::_Sign_of<3600>::value
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?value@?$_Abs@$0OBA@@std@@2_JB			; std::_Abs<3600>::value
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?value@?$_GcdX@$0OBA@$00@std@@2_JB		; std::_GcdX<3600,1>::value
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?value@?$_Gcd@$0OBA@$00@std@@2_JB		; std::_Gcd<3600,1>::value
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?value@?$_Sign_of@$0DM@@std@@2_JB		; std::_Sign_of<60>::value
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?num@?$ratio@$0OBA@$00@std@@2_JB		; std::ratio<3600,1>::num
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?den@?$ratio@$0OBA@$00@std@@2_JB		; std::ratio<3600,1>::den
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?value@?$_Abs@$0DM@@std@@2_JB			; std::_Abs<60>::value
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<3600,1> >::_N2
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<3600,1> >::_D2
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?value@?$_GcdX@$0DM@$00@std@@2_JB		; std::_GcdX<60,1>::value
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?value@?$_Gcd@$0DM@$00@std@@2_JB		; std::_Gcd<60,1>::value
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_N1
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_D1
PUBLIC	?num@?$ratio@$0DM@$00@std@@2_JB			; std::ratio<60,1>::num
PUBLIC	?den@?$ratio@$0DM@$00@std@@2_JB			; std::ratio<60,1>::den
PUBLIC	?value@?$_GcdX@$00$0OBA@@std@@2_JB		; std::_GcdX<1,3600>::value
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<60,1> >::_N2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<60,1> >::_D2
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?value@?$_Gcd@$00$0OBA@@std@@2_JB		; std::_Gcd<1,3600>::value
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?num@?$ratio@$00$0OBA@@std@@2_JB		; std::ratio<1,3600>::num
PUBLIC	?den@?$ratio@$00$0OBA@@std@@2_JB		; std::ratio<1,3600>::den
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_N1
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_N2
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_D1
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_D2
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_Gx
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_Gy
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?value@?$_GcdX@$00$0DM@@std@@2_JB		; std::_GcdX<1,60>::value
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?value@?$_Safe_multX@$0JIJGIA@$0OBA@$00@std@@2_JB ; std::_Safe_multX<10000000,3600,1>::value
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?value@?$_Gcd@$00$0DM@@std@@2_JB		; std::_Gcd<1,60>::value
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?value@?$_Safe_mult@$0JIJGIA@$0OBA@@std@@2_JB	; std::_Safe_mult<10000000,3600>::value
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?num@?$ratio@$00$0DM@@std@@2_JB			; std::ratio<1,60>::num
PUBLIC	?den@?$ratio@$00$0DM@@std@@2_JB			; std::ratio<1,60>::den
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?TicksPerMillisecond@TimeSpan@XNA@@2_JB		; XNA::TimeSpan::TicksPerMillisecond
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_N2
PUBLIC	?TicksPerSecond@TimeSpan@XNA@@2_JB		; XNA::TimeSpan::TicksPerSecond
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_D2
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?TicksPerMinute@TimeSpan@XNA@@2_JB		; XNA::TimeSpan::TicksPerMinute
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_Gx
PUBLIC	?TicksPerHour@TimeSpan@XNA@@2_JB		; XNA::TimeSpan::TicksPerHour
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_Gy
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?TicksPerDay@TimeSpan@XNA@@2_JB			; XNA::TimeSpan::TicksPerDay
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?MaxTicks@TimeSpan@XNA@@2_JB			; XNA::TimeSpan::MaxTicks
PUBLIC	?MinTicks@TimeSpan@XNA@@2_JB			; XNA::TimeSpan::MinTicks
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?value@?$_Safe_multX@$0JIJGIA@$0DM@$00@std@@2_JB ; std::_Safe_multX<10000000,60,1>::value
PUBLIC	?value@?$_Safe_mult@$0JIJGIA@$0DM@@std@@2_JB	; std::_Safe_mult<10000000,60>::value
PUBLIC	?value@?$_Always_false@H@std@@2_NB		; std::_Always_false<int>::value
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$_Sign_of@$0CDMDEGAA@@std@@2_JB		; std::_Sign_of<600000000>::value
PUBLIC	?value@?$_Abs@$0CDMDEGAA@@std@@2_JB		; std::_Abs<600000000>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?value@?$_Sign_of@$0IGBMEGIAA@@std@@2_JB	; std::_Sign_of<36000000000>::value
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$_Sign_of@$0GE@@std@@2_JB		; std::_Sign_of<100>::value
PUBLIC	?value@?$_Abs@$0IGBMEGIAA@@std@@2_JB		; std::_Abs<36000000000>::value
PUBLIC	?value@?$_GcdX@$0CDMDEGAA@$00@std@@2_JB		; std::_GcdX<600000000,1>::value
PUBLIC	?value@?$_Sign_of@$00@std@@2_JB			; std::_Sign_of<1>::value
PUBLIC	?value@?$_GcdX@$00$0CDMDEGAA@@std@@2_JB		; std::_GcdX<1,600000000>::value
PUBLIC	?value@?$_GcdX@$0IGBMEGIAA@$00@std@@2_JB	; std::_GcdX<36000000000,1>::value
PUBLIC	?value@?$_Gcd@$00$0CDMDEGAA@@std@@2_JB		; std::_Gcd<1,600000000>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_GcdX@$00$0IGBMEGIAA@@std@@2_JB	; std::_GcdX<1,36000000000>::value
PUBLIC	?num@?$ratio@$00$0CDMDEGAA@@std@@2_JB		; std::ratio<1,600000000>::num
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?den@?$ratio@$00$0CDMDEGAA@@std@@2_JB		; std::ratio<1,600000000>::den
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?value@?$_Gcd@$00$0IGBMEGIAA@@std@@2_JB		; std::_Gcd<1,36000000000>::value
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?num@?$ratio@$00$0IGBMEGIAA@@std@@2_JB		; std::ratio<1,36000000000>::num
PUBLIC	?den@?$ratio@$00$0IGBMEGIAA@@std@@2_JB		; std::ratio<1,36000000000>::den
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$0GE@$00@std@@2_JB		; std::_GcdX<100,1>::value
PUBLIC	?value@?$_Gcd@$0GE@$00@std@@2_JB		; std::_Gcd<100,1>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?num@?$ratio@$0GE@$00@std@@2_JB			; std::ratio<100,1>::num
PUBLIC	?den@?$ratio@$0GE@$00@std@@2_JB			; std::ratio<100,1>::den
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<60,1>,std::ratio<60,1> >::_N2
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<60,1>,std::ratio<60,1> >::_D2
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_N1
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_D1
PUBLIC	?value@?$_Sign_of@$0DLJKMKAA@@std@@2_JB		; std::_Sign_of<1000000000>::value
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_N1
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_D1
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_D2
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?value@?$_Always_false@_J@std@@2_NB		; std::_Always_false<__int64>::value
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$_GcdX@$0DM@$0A@@std@@2_JB		; std::_GcdX<60,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB		; std::_GcdX<1000000000,1>::value
PUBLIC	?value@?$_GcdX@$0DM@$0DM@@std@@2_JB		; std::_GcdX<60,60>::value
PUBLIC	?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB		; std::_GcdX<1,1000000000>::value
PUBLIC	?value@?$_Gcd@$0A@$0A@@std@@2_JB		; std::_Gcd<0,0>::value
PUBLIC	?value@?$_Gcd@$0DM@$0DM@@std@@2_JB		; std::_Gcd<60,60>::value
PUBLIC	?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB		; std::_Gcd<1,1000000000>::value
PUBLIC	?_Gx@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_Gx
PUBLIC	?_Gy@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_Gy
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB		; std::ratio<1,1000000000>::num
PUBLIC	?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB		; std::ratio<1,1000000000>::den
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_N2
PUBLIC	?_N2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<3600,1>,std::ratio<3600,1> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_D2
PUBLIC	?_D2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB ; std::_Ratio_divide<std::ratio<3600,1>,std::ratio<3600,1> >::_D2
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?_N1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_N1
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_D1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_D1
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?_N2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_N2
PUBLIC	?_D2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_D2
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?value@?$_GcdX@$0OBA@$0A@@std@@2_JB		; std::_GcdX<3600,0>::value
;	COMDAT ?value@?$_GcdX@$0OBA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0OBA@$0A@@std@@2_JB DQ 0000000000000e10H ; std::_GcdX<3600,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_N2
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_D1
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_N1
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<3600,1>,std::ratio<3600,1> >::_D2
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 000000003b9aca00H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$0OBA@$00@std@@U12@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_divide<std::ratio<3600,1>,std::ratio<3600,1> >::_N2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_N2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::ratio<1,1000000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,1000000000>::num
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_Gy
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_Gx
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DM@$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DM@$0DM@@std@@2_JB DQ 000000000000003cH	; std::_Gcd<60,60>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0A@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0A@$0A@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<0,0>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DM@$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DM@$0DM@@std@@2_JB DQ 000000000000003cH ; std::_GcdX<60,60>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1000000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DM@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DM@$0A@@std@@2_JB DQ 000000000000003cH	; std::_GcdX<60,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Always_false@_J@std@@2_NB
CONST	SEGMENT
?value@?$_Always_false@_J@std@@2_NB DB 00H		; std::_Always_false<__int64>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_N2
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_D1
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$0DM@$00@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_multiply<std::ratio<60,1>,std::ratio<1,60> >::_N1
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::_Sign_of<1000000000>::value
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_D1
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_N1
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<60,1>,std::ratio<60,1> >::_D2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$0DM@$00@std@@U12@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_divide<std::ratio<60,1>,std::ratio<60,1> >::_N2
CONST	ENDS
;	COMDAT ?den@?$ratio@$0GE@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<100,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$0GE@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0GE@$00@std@@2_JB DQ 0000000000000064H	; std::ratio<100,1>::num
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<100,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<100,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0IGBMEGIAA@@std@@2_JB DQ 0000000861c46800H ; std::ratio<1,36000000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0IGBMEGIAA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,36000000000>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0IGBMEGIAA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,36000000000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0CDMDEGAA@@std@@2_JB DQ 0000000023c34600H ; std::ratio<1,600000000>::den
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0CDMDEGAA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,600000000>::num
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0IGBMEGIAA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,36000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0CDMDEGAA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,600000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0IGBMEGIAA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0IGBMEGIAA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<36000000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0CDMDEGAA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,600000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$00@std@@2_JB DQ 0000000000000001H	; std::_Sign_of<1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0CDMDEGAA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0CDMDEGAA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<600000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0IGBMEGIAA@@std@@2_JB DQ 0000000861c46800H ; std::_Abs<36000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0GE@@std@@2_JB DQ 0000000000000001H	; std::_Sign_of<100>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0IGBMEGIAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0IGBMEGIAA@@std@@2_JB DQ 0000000000000001H ; std::_Sign_of<36000000000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0CDMDEGAA@@std@@2_JB DQ 0000000023c34600H ; std::_Abs<600000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0CDMDEGAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0CDMDEGAA@@std@@2_JB DQ 0000000000000001H ; std::_Sign_of<600000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Always_false@H@std@@2_NB
CONST	SEGMENT
?value@?$_Always_false@H@std@@2_NB DB 00H		; std::_Always_false<int>::value
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$0JIJGIA@$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$0JIJGIA@$0DM@@std@@2_JB DQ 0000000023c34600H ; std::_Safe_mult<10000000,60>::value
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$0JIJGIA@$0DM@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$0JIJGIA@$0DM@$00@std@@2_JB DQ 0000000023c34600H ; std::_Safe_multX<10000000,60,1>::value
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?MinTicks@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?MinTicks@TimeSpan@XNA@@2_JB DQ 8000000000000000H	; XNA::TimeSpan::MinTicks
CONST	ENDS
;	COMDAT ?MaxTicks@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?MaxTicks@TimeSpan@XNA@@2_JB DQ 7fffffffffffffffH	; XNA::TimeSpan::MaxTicks
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?TicksPerDay@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?TicksPerDay@TimeSpan@XNA@@2_JB DQ 000000c92a69c000H	; XNA::TimeSpan::TicksPerDay
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_Gy
CONST	ENDS
;	COMDAT ?TicksPerHour@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?TicksPerHour@TimeSpan@XNA@@2_JB DQ 0000000861c46800H	; XNA::TimeSpan::TicksPerHour
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_Gx
CONST	ENDS
;	COMDAT ?TicksPerMinute@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?TicksPerMinute@TimeSpan@XNA@@2_JB DQ 0000000023c34600H	; XNA::TimeSpan::TicksPerMinute
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_D2
CONST	ENDS
;	COMDAT ?TicksPerSecond@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?TicksPerSecond@TimeSpan@XNA@@2_JB DQ 0000000000989680H	; XNA::TimeSpan::TicksPerSecond
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_N2
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?TicksPerMillisecond@TimeSpan@XNA@@2_JB
CONST	SEGMENT
?TicksPerMillisecond@TimeSpan@XNA@@2_JB DQ 0000000000002710H ; XNA::TimeSpan::TicksPerMillisecond
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0DM@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0DM@@std@@2_JB DQ 000000000000003cH	; std::ratio<1,60>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0DM@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0DM@@std@@2_JB DQ 0000000000000001H	; std::ratio<1,60>::num
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$0JIJGIA@$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$0JIJGIA@$0OBA@@std@@2_JB DQ 0000000861c46800H ; std::_Safe_mult<10000000,3600>::value
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0DM@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,60>::value
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$0JIJGIA@$0OBA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$0JIJGIA@$0OBA@$00@std@@2_JB DQ 0000000861c46800H ; std::_Safe_multX<10000000,3600,1>::value
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0DM@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,60>::value
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_Gy
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_Gx
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_D2
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_D1
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_N2
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DM@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,60> >::_N1
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0OBA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0OBA@@std@@2_JB DQ 0000000000000e10H	; std::ratio<1,3600>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0OBA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0OBA@@std@@2_JB DQ 0000000000000001H	; std::ratio<1,3600>::num
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0OBA@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,3600>::value
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<60,1> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DM@$00@2@@std@@2_JB DQ 000000000000003cH ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<60,1> >::_N2
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0OBA@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,3600>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$0DM@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0DM@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<60,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$0DM@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0DM@$00@std@@2_JB DQ 000000000000003cH	; std::ratio<60,1>::num
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_D1
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,3600> >::_N1
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DM@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DM@$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<60,1>::value
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DM@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DM@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<60,1>::value
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<3600,1> >::_D2
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0OBA@$00@2@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<3600,1> >::_N2
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DM@@std@@2_JB DQ 000000000000003cH	; std::_Abs<60>::value
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?den@?$ratio@$0OBA@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0OBA@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<3600,1>::den
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?num@?$ratio@$0OBA@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0OBA@$00@std@@2_JB DQ 0000000000000e10H	; std::ratio<3600,1>::num
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0DM@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0DM@@std@@2_JB DQ 0000000000000001H	; std::_Sign_of<60>::value
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0OBA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0OBA@$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<3600,1>::value
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0OBA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0OBA@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<3600,1>::value
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0OBA@@std@@2_JB DQ 0000000000000e10H	; std::_Abs<3600>::value
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0OBA@@std@@2_JB DQ 0000000000000001H	; std::_Sign_of<3600>::value
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_Gy
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_Gcd<1000,1000>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1> > >::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000,1000>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_Gx
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_N2
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_D1
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1000>,std::ratio<1000,1> >::_N1
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_divide<std::ratio<1,1000>,std::ratio<1,1000> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0DOI@@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,1000>,std::ratio<1,1000> >::_N2
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_Gy
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<int,std::ratio<60,1> > >::value
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_Gx
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_D2
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0CHBA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0CHBA@@std@@2_JB DQ 0000000000002710H	; std::ratio<1,10000>::den
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_N2
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0CHBA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0CHBA@@std@@2_JB DQ 0000000000000001H	; std::ratio<1,10000>::num
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0CHBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0CHBA@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,10000>::value
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?den@?$ratio@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::ratio<10000000,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0JIJGIA@$00@std@@2_JB DQ 0000000000989680H ; std::ratio<10000000,1>::num
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0CHBA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0CHBA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000>::value
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_Gcd<10000000,1>::value
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0CHBA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0CHBA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000,1>::value
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_D1
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<10000000,1> >::_N1
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0CHBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0CHBA@@std@@2_JB DQ 0000000000000001H ; std::_Sign_of<10000>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,10000000> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,10000000> >::_N2
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1000> > >::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$0CHBA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$0CHBA@$00@std@@2_JB DQ 0000000000002710H ; std::_Safe_mult<10000,1>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$0CHBA@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$0CHBA@$00$00@std@@2_JB DQ 0000000000002710H ; std::_Safe_multX<10000,1,1>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Sign_of<10000000>::value
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0CHBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0CHBA@@std@@2_JB DQ 0000000000002710H	; std::_Abs<10000>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_Gy
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DOI@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DOI@$0JIJGIA@@std@@2_JB DQ 00000000000003e8H ; std::_Gcd<1000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$0JIJGIA@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<10000000,1000>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$0A@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000,0>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<int,std::ratio<3600,1> > >::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_Gx
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_N2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$0DOI@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0DOI@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1000,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$0DOI@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0DOI@$00@std@@2_JB DQ 00000000000003e8H	; std::ratio<1000,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DOI@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DOI@$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1000,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_D1
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1000,1> >::_N1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1000> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$0DOI@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1000> >::_N2
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0DOI@@std@@2_JB DQ 00000000000003e8H	; std::ratio<1,1000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1000>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_Gy
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_Gx
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_D2
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1000>::value
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_N2
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_D1
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,1>,std::ratio<1,1> >::_N1
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1000,1>::value
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,1>,std::ratio<1,1> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,1>,std::ratio<1,1> >::_N2
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DOI@@std@@2_JB DQ 00000000000003e8H	; std::_Abs<1000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Sign_of@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Sign_of@$0DOI@@std@@2_JB DQ 0000000000000001H	; std::_Sign_of<1000>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,1> >::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$0DM@$00@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$0DM@$00@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<60,1> >::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$0JIJGIA@$00@std@@2_JB DQ 0000000000989680H ; std::_Safe_mult<10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$0JIJGIA@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$0JIJGIA@$00$00@std@@2_JB DQ 0000000000989680H ; std::_Safe_multX<10000000,1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,1000> >::value
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Safe_mult<1,10000000>::value
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_Gy
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_Gx
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_D2
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_N2
CONST	ENDS
;	COMDAT ?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_D1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_D1
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$00$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$00$0JIJGIA@$00@std@@2_JB DQ 0000000000989680H ; std::_Safe_multX<1,10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$0OBA@$00@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$0OBA@$00@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<3600,1> >::value
CONST	ENDS
;	COMDAT ?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_N1@?$_Ratio_multiply@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<1,10000000>,std::ratio<1,1> >::_N1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_D2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1> >::_D2
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_N2@?$_Ratio_divide@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_divide<std::ratio<1,10000000>,std::ratio<1,1> >::_N2
CONST	ENDS
;	COMDAT ?value@?$_Safe_mult@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_mult@$00$00@std@@2_JB DQ 0000000000000001H ; std::_Safe_mult<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Lcm<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?_Gx@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Lcm@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Lcm<10000000,10000000>::_Gx
CONST	ENDS
;	COMDAT ?value@?$_Safe_multX@$00$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Safe_multX@$00$00$00@std@@2_JB DQ 0000000000000001H ; std::_Safe_multX<1,1,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_Gy
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?_Gy@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_Gy@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_Gy
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$0OBA@$00@std@@U?$ratio@$00$0OBA@@2@@std@@2_JB DQ 0000000000000e10H ; std::_Ratio_multiply<std::ratio<3600,1>,std::ratio<1,3600> >::_Gx
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0OBA@$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0OBA@$0OBA@@std@@2_JB DQ 0000000000000e10H ; std::_Gcd<3600,3600>::value
CONST	ENDS
;	COMDAT ?_Gx@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Ratio_multiply@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply<std::ratio<100,1>,std::ratio<1,1000000000> >::_Gx
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0OBA@$0OBA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0OBA@$0OBA@@std@@2_JB DQ 0000000000000e10H ; std::_GcdX<3600,3600>::value
CONST	ENDS
PUBLIC	_hypot
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-
PUBLIC	??Y?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
PUBLIC	??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ; XNA::TimeSpan::TimeSpan
PUBLIC	??0TimeSpan@XNA@@QAE@_J@Z			; XNA::TimeSpan::TimeSpan
PUBLIC	??0TimeSpan@XNA@@QAE@_J00@Z			; XNA::TimeSpan::TimeSpan
PUBLIC	??0TimeSpan@XNA@@QAE@_J000@Z			; XNA::TimeSpan::TimeSpan
PUBLIC	??0TimeSpan@XNA@@QAE@_J0000@Z			; XNA::TimeSpan::TimeSpan
PUBLIC	??HXNA@@YA?AVTimeSpan@0@ABV10@0@Z		; XNA::operator+
PUBLIC	??GXNA@@YA?AVTimeSpan@0@ABV10@0@Z		; XNA::operator-
PUBLIC	??8XNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator==
PUBLIC	??OXNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator>
PUBLIC	??MXNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator<
PUBLIC	??9XNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator!=
PUBLIC	??PXNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator>=
PUBLIC	??NXNA@@YA_NABVTimeSpan@0@0@Z			; XNA::operator<=
PUBLIC	??GTimeSpan@XNA@@QAE?AV01@XZ			; XNA::TimeSpan::operator-
PUBLIC	?GetDays@TimeSpan@XNA@@QAE_JXZ			; XNA::TimeSpan::GetDays
PUBLIC	?GetHours@TimeSpan@XNA@@QAE_JXZ			; XNA::TimeSpan::GetHours
PUBLIC	?GetMilliseconds@TimeSpan@XNA@@QAE_JXZ		; XNA::TimeSpan::GetMilliseconds
PUBLIC	?GetMinutes@TimeSpan@XNA@@QAE_JXZ		; XNA::TimeSpan::GetMinutes
PUBLIC	?GetSeconds@TimeSpan@XNA@@QAE_JXZ		; XNA::TimeSpan::GetSeconds
PUBLIC	?GetTicks@TimeSpan@XNA@@QAE_JXZ			; XNA::TimeSpan::GetTicks
PUBLIC	?GetTotalDays@TimeSpan@XNA@@QAENXZ		; XNA::TimeSpan::GetTotalDays
PUBLIC	?GetTotalHours@TimeSpan@XNA@@QAENXZ		; XNA::TimeSpan::GetTotalHours
PUBLIC	?GetTotalMilliseconds@TimeSpan@XNA@@QAENXZ	; XNA::TimeSpan::GetTotalMilliseconds
PUBLIC	?GetTotalMinutes@TimeSpan@XNA@@QAENXZ		; XNA::TimeSpan::GetTotalMinutes
PUBLIC	?GetTotalSeconds@TimeSpan@XNA@@QAENXZ		; XNA::TimeSpan::GetTotalSeconds
PUBLIC	?Duration@TimeSpan@XNA@@QAE?AV12@XZ		; XNA::TimeSpan::Duration
PUBLIC	?CompareTo@TimeSpan@XNA@@QAEHABV12@@Z		; XNA::TimeSpan::CompareTo
PUBLIC	?ToString@TimeSpan@XNA@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; XNA::TimeSpan::ToString
PUBLIC	?FromDays@TimeSpan@XNA@@SA?AV12@N@Z		; XNA::TimeSpan::FromDays
PUBLIC	?FromHours@TimeSpan@XNA@@SA?AV12@N@Z		; XNA::TimeSpan::FromHours
PUBLIC	?FromMilliseconds@TimeSpan@XNA@@SA?AV12@N@Z	; XNA::TimeSpan::FromMilliseconds
PUBLIC	?FromMinutes@TimeSpan@XNA@@SA?AV12@N@Z		; XNA::TimeSpan::FromMinutes
PUBLIC	?FromSeconds@TimeSpan@XNA@@SA?AV12@N@Z		; XNA::TimeSpan::FromSeconds
PUBLIC	?FromTicks@TimeSpan@XNA@@SA?AV12@_J@Z		; XNA::TimeSpan::FromTicks
PUBLIC	??$?H_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator+<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator><__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?9_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator!=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?P_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator>=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?N_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<3600,1> >,__int64,std::ratio<1,10000000> >
PUBLIC	?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ ; std::chrono::duration<int,std::ratio<3600,1> >::count
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	??$duration_cast@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0DM@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<60,1> >,__int64,std::ratio<1,10000000> >
PUBLIC	?count@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QBEHXZ ; std::chrono::duration<int,std::ratio<60,1> >::count
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,10000000> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
PUBLIC	??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?Zero@TimeSpan@XNA@@2V12@B			; XNA::TimeSpan::Zero
PUBLIC	??_C@_1DK@JPIFMGNP@?$AAb?$AA?3?$AA?2?$AAv?$AAs?$AA2?$AA0?$AA1?$AA3?$AA?2?$AAv?$AAc?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAx?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4038000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@408f400000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp__floor:PROC
EXTRN	__imp___hypot:PROC
EXTRN	__imp__sprintf_s:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0id@locale@std@@QAE@I@Z:PROC
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAPBDH@Z:PROC
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__dtol3:PROC
EXTRN	__ltod3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

?Zero@TimeSpan@XNA@@2V12@B DQ 01H DUP (?)		; XNA::TimeSpan::Zero
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4038000000000000
CONST	SEGMENT
__real@4038000000000000 DQ 04038000000000000r	; 24
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JPIFMGNP@?$AAb?$AA?3?$AA?2?$AAv?$AAs?$AA2?$AA0?$AA1?$AA3?$AA?2?$AAv?$AAc?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAx?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JPIFMGNP@?$AAb?$AA?3?$AA?2?$AAv?$AAs?$AA2?$AA0?$AA1?$AA3?$AA?2?$AAv?$AAc?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAx?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 'b'
	DB	00H, ':', 00H, '\', 00H, 'v', 00H, 's', 00H, '2', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H
	DB	'\', 00H, 'x', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d?$AA@ DB '%I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?Zero$initializer$@TimeSpan@XNA@@2P6AXXZA DD FLAT:??__E?Zero@TimeSpan@XNA@@2V12@B@@YAXXZ ; XNA::TimeSpan::Zero$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 04		 push	 4
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00064	74 24		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0006f	83 c4 04	 add	 esp, 4
  00072	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 02		 mov	 DWORD PTR [edx], eax
  0007c	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00082	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00088	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0008a	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  00094	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  0009a	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  000a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000bb	3b ec		 cmp	 ebp, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z PROC ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ENDP ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z PROC ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ENDP ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
  00023	e8 00 00 00 00	 call	 ??1_System_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
  00023	e8 00 00 00 00	 call	 ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00023	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00023	e8 00 00 00 00	 call	 ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
  00023	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
  00023	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  00028	68 00 00 00 00	 push	 OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 23   : 	void *_Ptr = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  0002b	eb 2a		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0002d	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00031	77 15		 ja	 SHORT $LN1@Allocate
  00033	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00042	83 7d f8 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00046	75 0f		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00048	8b f4		 mov	 esi, esp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 23   : 	void *_Ptr = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  0002b	eb 30		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0002d	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00034	77 18		 ja	 SHORT $LN1@Allocate
  00036	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00039	c1 e0 03	 shl	 eax, 3
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00048	83 7d f8 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0004c	75 0f		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0004e	8b f4		 mov	 esi, esp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0005d	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00045	50		 push	 eax
  00046	6a 08		 push	 8
  00048	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  00064	74 2a		 je	 SHORT $LN3@construct
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0006f	83 c4 04	 add	 esp, 4
  00072	8b 10		 mov	 edx, DWORD PTR [eax]
  00074	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00077	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  0007d	89 11		 mov	 DWORD PTR [ecx], edx
  0007f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00082	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00088	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], edx
  0008e	eb 0a		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00090	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0009a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  000a0	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  000a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00023	6a 00		 push	 0
  00025	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
  0002e	83 c4 08	 add	 esp, 8

; 579  : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	83 c4 04	 add	 esp, 4

; 574  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  00030	83 c4 08	 add	 esp, 8

; 880  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 132  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,10000000> >, COMDAT

; 536  : 	{	// convert duration to another duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

  0001e	33 c0		 xor	 eax, eax
  00020	74 30		 je	 SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00025	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002a	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00030	89 95 08 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00036	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00048	e9 a8 00 00 00	 jmp	 $LN7@duration_c
  0004d	e9 a3 00 00 00	 jmp	 $LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

  00052	33 c0		 xor	 eax, eax
  00054	74 2a		 je	 SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<_ToRep>(

  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00059	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0005e	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00064	89 95 18 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0006a	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00074	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  00079	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007c	eb 77		 jmp	 SHORT $LN7@duration_c
  0007e	eb 75		 jmp	 SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	74 38		 je	 SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<_ToRep>(

  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0008c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00091	6a 00		 push	 0
  00093	68 80 96 98 00	 push	 10000000		; 00989680H
  00098	52		 push	 edx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 __alldiv
  0009f	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  000a5	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T3[ebp+4], edx
  000ab	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  000ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	eb 36		 jmp	 SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

  000bf	eb 34		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<_ToRep>(

  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000c4	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000c9	6a 00		 push	 0
  000cb	68 80 96 98 00	 push	 10000000		; 00989680H
  000d0	52		 push	 edx
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 __alldiv
  000d7	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  000dd	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  000e3	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ed	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
  000f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ?count@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QBEHXZ PROC ; std::chrono::duration<int,std::ratio<60,1> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 132  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?count@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QBEHXZ ENDP ; std::chrono::duration<int,std::ratio<60,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0DM@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
$T4 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0DM@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<60,1> >,__int64,std::ratio<1,10000000> >, COMDAT

; 536  : 	{	// convert duration to another duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

  0001e	33 c0		 xor	 eax, eax
  00020	74 2a		 je	 SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00025	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002a	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00030	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00042	e9 96 00 00 00	 jmp	 $LN7@duration_c
  00047	e9 91 00 00 00	 jmp	 $LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

  0004c	33 c0		 xor	 eax, eax
  0004e	74 24		 je	 SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<_ToRep>(

  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00053	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00058	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0005e	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00064	50		 push	 eax
  00065	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00068	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	eb 6b		 jmp	 SHORT $LN7@duration_c
  00072	eb 69		 jmp	 SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	85 c0		 test	 eax, eax
  0007b	74 32		 je	 SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<_ToRep>(

  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00080	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00085	6a 00		 push	 0
  00087	68 00 46 c3 23	 push	 600000000		; 23c34600H
  0008c	52		 push	 edx
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 __alldiv
  00093	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00099	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a3	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	eb 30		 jmp	 SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

  000ad	eb 2e		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<_ToRep>(

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b2	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000b7	6a 00		 push	 0
  000b9	68 00 46 c3 23	 push	 600000000		; 23c34600H
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 __alldiv
  000c5	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  000cb	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d5	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<60,1> >::duration<int,std::ratio<60,1> ><int,void>
  000da	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
??$duration_cast@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0DM@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<60,1> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 132  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000> >, COMDAT

; 536  : 	{	// convert duration to another duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

  0001e	33 c0		 xor	 eax, eax
  00020	74 30		 je	 SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00025	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002a	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00030	89 95 08 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00036	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00048	e9 a8 00 00 00	 jmp	 $LN7@duration_c
  0004d	e9 a3 00 00 00	 jmp	 $LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

  00052	33 c0		 xor	 eax, eax
  00054	74 2a		 je	 SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<_ToRep>(

  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00059	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0005e	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00064	89 95 18 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0006a	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00074	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
  00079	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007c	eb 77		 jmp	 SHORT $LN7@duration_c
  0007e	eb 75		 jmp	 SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	74 38		 je	 SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<_ToRep>(

  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  0008c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00091	6a 00		 push	 0
  00093	68 10 27 00 00	 push	 10000			; 00002710H
  00098	52		 push	 edx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 __alldiv
  0009f	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  000a5	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T3[ebp+4], edx
  000ab	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
  000ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	eb 36		 jmp	 SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

  000bf	eb 34		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<_ToRep>(

  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000c4	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000c9	6a 00		 push	 0
  000cb	68 10 27 00 00	 push	 10000			; 00002710H
  000d0	52		 push	 edx
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 __alldiv
  000d7	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  000dd	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  000e3	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ed	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
  000f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ PROC ; std::chrono::duration<int,std::ratio<3600,1> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 132  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ ENDP ; std::chrono::duration<int,std::ratio<3600,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
$T4 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<3600,1> >,__int64,std::ratio<1,10000000> >, COMDAT

; 536  : 	{	// convert duration to another duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 538  : 	typedef typename _To::rep _ToRep;
; 539  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

  0001e	33 c0		 xor	 eax, eax
  00020	74 2a		 je	 SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<_ToRep>(_Dur.count())));

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00025	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002a	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00030	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00042	e9 96 00 00 00	 jmp	 $LN7@duration_c
  00047	e9 91 00 00 00	 jmp	 $LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

  0004c	33 c0		 xor	 eax, eax
  0004e	74 24		 je	 SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<_ToRep>(

  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00053	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00058	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0005e	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00064	50		 push	 eax
  00065	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00068	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	eb 6b		 jmp	 SHORT $LN7@duration_c
  00072	eb 69		 jmp	 SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num))));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	85 c0		 test	 eax, eax
  0007b	74 32		 je	 SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<_ToRep>(

  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  00080	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00085	6a 08		 push	 8
  00087	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  0008c	52		 push	 edx
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 __alldiv
  00093	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00099	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a3	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	eb 30		 jmp	 SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

  000ad	eb 2e		 jmp	 SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<_ToRep>(

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR __Dur$[ebp]
  000b2	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  000b7	6a 08		 push	 8
  000b9	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 __alldiv
  000c5	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  000cb	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d5	e8 00 00 00 00	 call	 ??$?0HX@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<int,std::ratio<3600,1> >::duration<int,std::ratio<3600,1> ><int,void>
  000da	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<3600,1> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?N_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?N_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator<=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 503  : 	{	// test if duration <= duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 504  : 	return (!(_Right < _Left));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 d0	 movzx	 edx, al
  00031	85 d2		 test	 edx, edx
  00033	75 0c		 jne	 SHORT $LN3@operator
  00035	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00041	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004b	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 505  : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?N_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator<=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?P_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?P_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator>=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 525  : 	{	// test if duration >= duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 526  : 	return (!(_Left < _Right));

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 d0	 movzx	 edx, al
  00031	85 d2		 test	 edx, edx
  00033	75 0c		 jne	 SHORT $LN3@operator
  00035	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00041	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004b	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 527  : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?P_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator>=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?9_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator!=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 478  : 	{	// test if duration != duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 479  : 	return (!(_Left == _Right));

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 d0	 movzx	 edx, al
  00031	85 d2		 test	 edx, edx
  00033	75 0c		 jne	 SHORT $LN3@operator
  00035	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00041	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004b	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]

; 480  : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?9_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator!=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
tv71 = -244						; size = 4
tv94 = -240						; size = 8
tv91 = -232						; size = 8
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 489  : 	{	// test if duration < duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 490  : 	typedef typename common_type<
; 491  : 		duration<_Rep1, _Period1>,
; 492  : 		duration<_Rep2, _Period2> >::type _CT;
; 493  : 	return (_CT(_Left).count() < _CT(_Right).count());

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002c	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00032	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003a	89 8d 34 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00040	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  00046	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00051	8b f0		 mov	 esi, eax
  00053	8b fa		 mov	 edi, edx
  00055	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0005b	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00060	89 b5 18 ff ff
	ff		 mov	 DWORD PTR tv91[ebp], esi
  00066	89 bd 1c ff ff
	ff		 mov	 DWORD PTR tv91[ebp+4], edi
  0006c	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  00072	89 95 14 ff ff
	ff		 mov	 DWORD PTR tv94[ebp+4], edx
  00078	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv91[ebp+4]
  0007e	3b 85 14 ff ff
	ff		 cmp	 eax, DWORD PTR tv94[ebp+4]
  00084	7f 1c		 jg	 SHORT $LN3@operator
  00086	7c 0e		 jl	 SHORT $LN5@operator
  00088	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv91[ebp]
  0008e	3b 8d 10 ff ff
	ff		 cmp	 ecx, DWORD PTR tv94[ebp]
  00094	73 0c		 jae	 SHORT $LN3@operator
$LN5@operator:
  00096	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  000a0	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  000a2	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  000ac	8a 85 0c ff ff
	ff		 mov	 al, BYTE PTR tv71[ebp]

; 494  : 	}

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000bb	3b ec		 cmp	 ebp, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator><__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 514  : 	{	// test if duration > duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 515  : 	return (_Right < _Left);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 516  : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator><__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z
_TEXT	SEGMENT
tv71 = -244						; size = 4
tv94 = -240						; size = 8
tv91 = -232						; size = 8
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z PROC ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 464  : 	{	// test if duration == duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 465  : 	typedef typename common_type<
; 466  : 		duration<_Rep1, _Period1>,
; 467  : 		duration<_Rep2, _Period2> >::type _CT;
; 468  : 	return (_CT(_Left).count() == _CT(_Right).count());

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002c	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00032	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003a	89 8d 34 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00040	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  00046	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004c	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00051	8b f0		 mov	 esi, eax
  00053	8b fa		 mov	 edi, edx
  00055	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0005b	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00060	89 b5 18 ff ff
	ff		 mov	 DWORD PTR tv91[ebp], esi
  00066	89 bd 1c ff ff
	ff		 mov	 DWORD PTR tv91[ebp+4], edi
  0006c	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  00072	89 95 14 ff ff
	ff		 mov	 DWORD PTR tv94[ebp+4], edx
  00078	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  0007e	3b 85 10 ff ff
	ff		 cmp	 eax, DWORD PTR tv94[ebp]
  00084	75 1a		 jne	 SHORT $LN3@operator
  00086	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv91[ebp+4]
  0008c	3b 8d 14 ff ff
	ff		 cmp	 ecx, DWORD PTR tv94[ebp+4]
  00092	75 0c		 jne	 SHORT $LN3@operator
  00094	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  0009e	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  000a0	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  000aa	8a 85 0c ff ff
	ff		 mov	 al, BYTE PTR tv71[ebp]

; 469  : 	}

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ENDP ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 365  : 	{	// subtract two durations

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 366  : 	typedef typename common_type<
; 367  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 368  : 	return (_CD(_Left) -= _Right);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	89 8d 34 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002c	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00032	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	50		 push	 eax
  00036	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0003c	e8 00 00 00 00	 call	 ??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 369  : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?H_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator+<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 348  : 	{	// add two durations

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 349  : 	typedef typename common_type<
; 350  : 		duration<_Rep1, _Period1>,
; 351  : 		duration<_Rep2, _Period2> >::type _CD;
; 352  : 		return (_CD(_Left) += _Right);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	89 8d 34 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002c	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00032	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	50		 push	 eax
  00036	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0003c	e8 00 00 00 00	 call	 ??Y?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator+=
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 353  : 		}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$?H_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator+<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??__E?Zero@TimeSpan@XNA@@2V12@B@@YAXXZ
text$di	SEGMENT
??__E?Zero@TimeSpan@XNA@@2V12@B@@YAXXZ PROC		; `dynamic initializer for 'XNA::TimeSpan::Zero'', COMDAT

; 5    : 	const TimeSpan TimeSpan::Zero(0);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?Zero@TimeSpan@XNA@@2V12@B ; XNA::TimeSpan::Zero
  00027	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J@Z ; XNA::TimeSpan::TimeSpan
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??__E?Zero@TimeSpan@XNA@@2V12@B@@YAXXZ ENDP		; `dynamic initializer for 'XNA::TimeSpan::Zero''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromTicks@TimeSpan@XNA@@SA?AV12@_J@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromTicks@TimeSpan@XNA@@SA?AV12@_J@Z PROC		; XNA::TimeSpan::FromTicks, COMDAT

; 184  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 185  : 		return TimeSpan(val);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _val$[ebp+4]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _val$[ebp]
  00025	51		 push	 ecx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J@Z ; XNA::TimeSpan::TimeSpan
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 186  : 	}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?FromTicks@TimeSpan@XNA@@SA?AV12@_J@Z ENDP		; XNA::TimeSpan::FromTicks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromSeconds@TimeSpan@XNA@@SA?AV12@N@Z
_TEXT	SEGMENT
tv84 = -216						; size = 8
_mil$ = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromSeconds@TimeSpan@XNA@@SA?AV12@N@Z PROC		; XNA::TimeSpan::FromSeconds, COMDAT

; 179  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 180  : 		double mil = (val - std::floor(val)) * 1000;

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	dd 9d 28 ff ff
	ff		 fstp	 QWORD PTR tv84[ebp]
  00043	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00048	f2 0f 5c 85 28
	ff ff ff	 subsd	 xmm0, QWORD PTR tv84[ebp]
  00050	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  00058	f2 0f 11 45 f4	 movsd	 QWORD PTR _mil$[ebp], xmm0

; 181  : 		return TimeSpan(0, 0, 0, (i64)val, (i64)mil);

  0005d	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _mil$[ebp]
  00062	e8 00 00 00 00	 call	 __dtol3
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  0006e	e8 00 00 00 00	 call	 __dtol3
  00073	52		 push	 edx
  00074	50		 push	 eax
  00075	6a 00		 push	 0
  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00084	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J0000@Z ; XNA::TimeSpan::TimeSpan
  00089	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 182  : 	}

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?FromSeconds@TimeSpan@XNA@@SA?AV12@N@Z ENDP		; XNA::TimeSpan::FromSeconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromMinutes@TimeSpan@XNA@@SA?AV12@N@Z
_TEXT	SEGMENT
tv132 = -232						; size = 8
tv91 = -232						; size = 8
_mil$ = -28						; size = 8
_sec$ = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromMinutes@TimeSpan@XNA@@SA?AV12@N@Z PROC		; XNA::TimeSpan::FromMinutes, COMDAT

; 172  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 173  : 		double sec = (val - std::floor(val)) * 60;

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	dd 9d 18 ff ff
	ff		 fstp	 QWORD PTR tv91[ebp]
  00043	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00048	f2 0f 5c 85 18
	ff ff ff	 subsd	 xmm0, QWORD PTR tv91[ebp]
  00050	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404e000000000000
  00058	f2 0f 11 45 f4	 movsd	 QWORD PTR _sec$[ebp], xmm0

; 174  : 		double mil = (sec - std::floor(sec)) * 1000;

  0005d	8b f4		 mov	 esi, esp
  0005f	83 ec 08	 sub	 esp, 8
  00062	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  00067	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00072	83 c4 08	 add	 esp, 8
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	dd 9d 18 ff ff
	ff		 fstp	 QWORD PTR tv132[ebp]
  00082	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  00087	f2 0f 5c 85 18
	ff ff ff	 subsd	 xmm0, QWORD PTR tv132[ebp]
  0008f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  00097	f2 0f 11 45 e4	 movsd	 QWORD PTR _mil$[ebp], xmm0

; 175  : 		return TimeSpan(0, 0, (i64)val, (i64)sec, (i64)mil);

  0009c	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _mil$[ebp]
  000a1	e8 00 00 00 00	 call	 __dtol3
  000a6	52		 push	 edx
  000a7	50		 push	 eax
  000a8	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  000ad	e8 00 00 00 00	 call	 __dtol3
  000b2	52		 push	 edx
  000b3	50		 push	 eax
  000b4	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  000b9	e8 00 00 00 00	 call	 __dtol3
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000cb	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J0000@Z ; XNA::TimeSpan::TimeSpan
  000d0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 176  : 	}

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?FromMinutes@TimeSpan@XNA@@SA?AV12@N@Z ENDP		; XNA::TimeSpan::FromMinutes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromMilliseconds@TimeSpan@XNA@@SA?AV12@N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromMilliseconds@TimeSpan@XNA@@SA?AV12@N@Z PROC	; XNA::TimeSpan::FromMilliseconds, COMDAT

; 168  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 169  : 		return TimeSpan(0, 0, 0, 0, (i64)val);

  0001e	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00023	e8 00 00 00 00	 call	 __dtol3
  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J0000@Z ; XNA::TimeSpan::TimeSpan
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 170  : 	}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?FromMilliseconds@TimeSpan@XNA@@SA?AV12@N@Z ENDP	; XNA::TimeSpan::FromMilliseconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromHours@TimeSpan@XNA@@SA?AV12@N@Z
_TEXT	SEGMENT
tv148 = -248						; size = 8
tv139 = -248						; size = 8
tv130 = -248						; size = 8
_mil$ = -44						; size = 8
_sec$ = -28						; size = 8
_min$ = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromHours@TimeSpan@XNA@@SA?AV12@N@Z PROC		; XNA::TimeSpan::FromHours, COMDAT

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 161  : 		double min = (val - std::floor(val)) * 60;

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	dd 9d 08 ff ff
	ff		 fstp	 QWORD PTR tv130[ebp]
  00043	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00048	f2 0f 5c 85 08
	ff ff ff	 subsd	 xmm0, QWORD PTR tv130[ebp]
  00050	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404e000000000000
  00058	f2 0f 11 45 f4	 movsd	 QWORD PTR _min$[ebp], xmm0

; 162  : 		double sec = (min - std::floor(min)) * 60;

  0005d	8b f4		 mov	 esi, esp
  0005f	83 ec 08	 sub	 esp, 8
  00062	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  00067	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00072	83 c4 08	 add	 esp, 8
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	dd 9d 08 ff ff
	ff		 fstp	 QWORD PTR tv139[ebp]
  00082	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  00087	f2 0f 5c 85 08
	ff ff ff	 subsd	 xmm0, QWORD PTR tv139[ebp]
  0008f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404e000000000000
  00097	f2 0f 11 45 e4	 movsd	 QWORD PTR _sec$[ebp], xmm0

; 163  : 		double mil = (sec - std::floor(sec)) * 1000;

  0009c	8b f4		 mov	 esi, esp
  0009e	83 ec 08	 sub	 esp, 8
  000a1	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  000a6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	dd 9d 08 ff ff
	ff		 fstp	 QWORD PTR tv148[ebp]
  000c1	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  000c6	f2 0f 5c 85 08
	ff ff ff	 subsd	 xmm0, QWORD PTR tv148[ebp]
  000ce	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  000d6	f2 0f 11 45 d4	 movsd	 QWORD PTR _mil$[ebp], xmm0

; 164  : 		return TimeSpan(0, (i64)val, (i64)min, (i64)sec, (i64)mil);

  000db	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _mil$[ebp]
  000e0	e8 00 00 00 00	 call	 __dtol3
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  000ec	e8 00 00 00 00	 call	 __dtol3
  000f1	52		 push	 edx
  000f2	50		 push	 eax
  000f3	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  000f8	e8 00 00 00 00	 call	 __dtol3
  000fd	52		 push	 edx
  000fe	50		 push	 eax
  000ff	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00104	e8 00 00 00 00	 call	 __dtol3
  00109	52		 push	 edx
  0010a	50		 push	 eax
  0010b	6a 00		 push	 0
  0010d	6a 00		 push	 0
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00112	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J0000@Z ; XNA::TimeSpan::TimeSpan
  00117	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 165  : 	}

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00123	3b ec		 cmp	 ebp, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?FromHours@TimeSpan@XNA@@SA?AV12@N@Z ENDP		; XNA::TimeSpan::FromHours
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?FromDays@TimeSpan@XNA@@SA?AV12@N@Z
_TEXT	SEGMENT
tv164 = -264						; size = 8
tv155 = -264						; size = 8
tv146 = -264						; size = 8
tv137 = -264						; size = 8
_mil$ = -60						; size = 8
_sec$ = -44						; size = 8
_min$ = -28						; size = 8
_hr$ = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
_val$ = 12						; size = 8
?FromDays@TimeSpan@XNA@@SA?AV12@N@Z PROC		; XNA::TimeSpan::FromDays, COMDAT

; 151  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 152  : 		double hr = (val - std::floor(val)) * 24;

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	dd 9d f8 fe ff
	ff		 fstp	 QWORD PTR tv137[ebp]
  00043	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  00048	f2 0f 5c 85 f8
	fe ff ff	 subsd	 xmm0, QWORD PTR tv137[ebp]
  00050	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4038000000000000
  00058	f2 0f 11 45 f4	 movsd	 QWORD PTR _hr$[ebp], xmm0

; 153  : 		double min = (hr - std::floor(hr)) * 60;

  0005d	8b f4		 mov	 esi, esp
  0005f	83 ec 08	 sub	 esp, 8
  00062	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _hr$[ebp]
  00067	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00072	83 c4 08	 add	 esp, 8
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	dd 9d f8 fe ff
	ff		 fstp	 QWORD PTR tv146[ebp]
  00082	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _hr$[ebp]
  00087	f2 0f 5c 85 f8
	fe ff ff	 subsd	 xmm0, QWORD PTR tv146[ebp]
  0008f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404e000000000000
  00097	f2 0f 11 45 e4	 movsd	 QWORD PTR _min$[ebp], xmm0

; 154  : 		double sec = (min - std::floor(min)) * 60;

  0009c	8b f4		 mov	 esi, esp
  0009e	83 ec 08	 sub	 esp, 8
  000a1	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  000a6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	dd 9d f8 fe ff
	ff		 fstp	 QWORD PTR tv155[ebp]
  000c1	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  000c6	f2 0f 5c 85 f8
	fe ff ff	 subsd	 xmm0, QWORD PTR tv155[ebp]
  000ce	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404e000000000000
  000d6	f2 0f 11 45 d4	 movsd	 QWORD PTR _sec$[ebp], xmm0

; 155  : 		double mil = (sec - std::floor(sec)) * 1000;

  000db	8b f4		 mov	 esi, esp
  000dd	83 ec 08	 sub	 esp, 8
  000e0	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  000e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  000f0	83 c4 08	 add	 esp, 8
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	dd 9d f8 fe ff
	ff		 fstp	 QWORD PTR tv164[ebp]
  00100	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  00105	f2 0f 5c 85 f8
	fe ff ff	 subsd	 xmm0, QWORD PTR tv164[ebp]
  0010d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  00115	f2 0f 11 45 c4	 movsd	 QWORD PTR _mil$[ebp], xmm0

; 156  : 		return TimeSpan((i64)val, (i64)hr, (i64)min, (i64)sec, (i64)mil);

  0011a	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR _mil$[ebp]
  0011f	e8 00 00 00 00	 call	 __dtol3
  00124	52		 push	 edx
  00125	50		 push	 eax
  00126	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _sec$[ebp]
  0012b	e8 00 00 00 00	 call	 __dtol3
  00130	52		 push	 edx
  00131	50		 push	 eax
  00132	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _min$[ebp]
  00137	e8 00 00 00 00	 call	 __dtol3
  0013c	52		 push	 edx
  0013d	50		 push	 eax
  0013e	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _hr$[ebp]
  00143	e8 00 00 00 00	 call	 __dtol3
  00148	52		 push	 edx
  00149	50		 push	 eax
  0014a	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _val$[ebp]
  0014f	e8 00 00 00 00	 call	 __dtol3
  00154	52		 push	 edx
  00155	50		 push	 eax
  00156	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00159	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@_J0000@Z ; XNA::TimeSpan::TimeSpan
  0015e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 157  : 	}

  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0016a	3b ec		 cmp	 ebp, esp
  0016c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
?FromDays@TimeSpan@XNA@@SA?AV12@N@Z ENDP		; XNA::TimeSpan::FromDays
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?ToString@TimeSpan@XNA@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?ToString@TimeSpan@XNA@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; XNA::TimeSpan::ToString, COMDAT
; _this$ = ecx

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 147  : 		return std::to_string(this->ticks.count());

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00049	83 c9 01	 or	 ecx, 1
  0004c	89 8d 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00052	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 	}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?ToString@TimeSpan@XNA@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; XNA::TimeSpan::ToString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?CompareTo@TimeSpan@XNA@@QAEHABV12@@Z
_TEXT	SEGMENT
tv82 = -212						; size = 4
tv85 = -208						; size = 4
_this$ = -8						; size = 4
_ts$ = 8						; size = 4
?CompareTo@TimeSpan@XNA@@QAEHABV12@@Z PROC		; XNA::TimeSpan::CompareTo, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 		return (this->ticks < ts.ticks ? -1
; 141  : 			: (this->ticks == ts.ticks ? 0
; 142  : 			: (this->ticks > ts.ticks)));

  00023	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  00030	83 c4 08	 add	 esp, 8
  00033	0f b6 d0	 movzx	 edx, al
  00036	85 d2		 test	 edx, edx
  00038	74 0c		 je	 SHORT $LN5@CompareTo
  0003a	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv85[ebp], -1
  00044	eb 48		 jmp	 SHORT $LN6@CompareTo
$LN5@CompareTo:
  00046	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  00053	83 c4 08	 add	 esp, 8
  00056	0f b6 d0	 movzx	 edx, al
  00059	85 d2		 test	 edx, edx
  0005b	74 0c		 je	 SHORT $LN3@CompareTo
  0005d	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
  00067	eb 19		 jmp	 SHORT $LN4@CompareTo
$LN3@CompareTo:
  00069	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator><__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  00076	83 c4 08	 add	 esp, 8
  00079	0f b6 d0	 movzx	 edx, al
  0007c	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv82[ebp], edx
$LN4@CompareTo:
  00082	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv82[ebp]
  00088	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN6@CompareTo:
  0008e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv85[ebp]

; 143  : 	}

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?CompareTo@TimeSpan@XNA@@QAEHABV12@@Z ENDP		; XNA::TimeSpan::CompareTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?Duration@TimeSpan@XNA@@QAE?AV12@XZ
_TEXT	SEGMENT
tv76 = -260						; size = 4
tv82 = -256						; size = 8
$T1 = -244						; size = 4
$T2 = -232						; size = 8
$T3 = -216						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Duration@TimeSpan@XNA@@QAE?AV12@XZ PROC		; XNA::TimeSpan::Duration, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00013	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 135  : 		return TimeSpan(this->ticks.count() < 0 ? -this->ticks : this->ticks);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  00031	89 95 04 ff ff
	ff		 mov	 DWORD PTR tv82[ebp+4], edx
  00037	83 bd 04 ff ff
	ff 00		 cmp	 DWORD PTR tv82[ebp+4], 0
  0003e	7f 22		 jg	 SHORT $LN3@Duration
  00040	7c 09		 jl	 SHORT $LN5@Duration
  00042	83 bd 00 ff ff
	ff 00		 cmp	 DWORD PTR tv82[ebp], 0
  00049	73 17		 jae	 SHORT $LN3@Duration
$LN5@Duration:
  0004b	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00051	50		 push	 eax
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-
  0005a	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00060	eb 20		 jmp	 SHORT $LN4@Duration
$LN3@Duration:
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0006a	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], edx
  00070	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  00076	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0007c	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv76[ebp], ecx
$LN4@Duration:
  00082	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00088	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  0008e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00098	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ; XNA::TimeSpan::TimeSpan
  0009d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 136  : 	}

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?Duration@TimeSpan@XNA@@QAE?AV12@XZ ENDP		; XNA::TimeSpan::Duration
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTotalSeconds@TimeSpan@XNA@@QAENXZ
_TEXT	SEGMENT
tv89 = -212						; size = 8
_this$ = -8						; size = 4
?GetTotalSeconds@TimeSpan@XNA@@QAENXZ PROC		; XNA::TimeSpan::GetTotalSeconds, COMDAT
; _this$ = ecx

; 128  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 		return (this->ticks.count() / TicksPerSecond);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	6a 00		 push	 0
  0002d	68 80 96 98 00	 push	 10000000		; 00989680H
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 __ltod3
  00040	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  00048	dd 85 2c ff ff
	ff		 fld	 QWORD PTR tv89[ebp]

; 130  : 	}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GetTotalSeconds@TimeSpan@XNA@@QAENXZ ENDP		; XNA::TimeSpan::GetTotalSeconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTotalMinutes@TimeSpan@XNA@@QAENXZ
_TEXT	SEGMENT
tv89 = -212						; size = 8
_this$ = -8						; size = 4
?GetTotalMinutes@TimeSpan@XNA@@QAENXZ PROC		; XNA::TimeSpan::GetTotalMinutes, COMDAT
; _this$ = ecx

; 123  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 		return (this->ticks.count() / TicksPerMinute);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	6a 00		 push	 0
  0002d	68 00 46 c3 23	 push	 600000000		; 23c34600H
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 __ltod3
  00040	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  00048	dd 85 2c ff ff
	ff		 fld	 QWORD PTR tv89[ebp]

; 125  : 	}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GetTotalMinutes@TimeSpan@XNA@@QAENXZ ENDP		; XNA::TimeSpan::GetTotalMinutes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTotalMilliseconds@TimeSpan@XNA@@QAENXZ
_TEXT	SEGMENT
tv89 = -212						; size = 8
_this$ = -8						; size = 4
?GetTotalMilliseconds@TimeSpan@XNA@@QAENXZ PROC		; XNA::TimeSpan::GetTotalMilliseconds, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		return (this->ticks.count() / TicksPerMillisecond);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	6a 00		 push	 0
  0002d	68 10 27 00 00	 push	 10000			; 00002710H
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 __ltod3
  00040	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  00048	dd 85 2c ff ff
	ff		 fld	 QWORD PTR tv89[ebp]

; 120  : 	}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GetTotalMilliseconds@TimeSpan@XNA@@QAENXZ ENDP		; XNA::TimeSpan::GetTotalMilliseconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTotalHours@TimeSpan@XNA@@QAENXZ
_TEXT	SEGMENT
tv89 = -212						; size = 8
_this$ = -8						; size = 4
?GetTotalHours@TimeSpan@XNA@@QAENXZ PROC		; XNA::TimeSpan::GetTotalHours, COMDAT
; _this$ = ecx

; 113  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 114  : 		return (this->ticks.count() / TicksPerHour);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	6a 08		 push	 8
  0002d	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 __ltod3
  00040	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  00048	dd 85 2c ff ff
	ff		 fld	 QWORD PTR tv89[ebp]

; 115  : 	}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GetTotalHours@TimeSpan@XNA@@QAENXZ ENDP		; XNA::TimeSpan::GetTotalHours
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTotalDays@TimeSpan@XNA@@QAENXZ
_TEXT	SEGMENT
tv89 = -212						; size = 8
_this$ = -8						; size = 4
?GetTotalDays@TimeSpan@XNA@@QAENXZ PROC			; XNA::TimeSpan::GetTotalDays, COMDAT
; _this$ = ecx

; 108  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00013	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 		return (this->ticks.count() / TicksPerDay);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	68 c9 00 00 00	 push	 201			; 000000c9H
  00030	68 00 c0 69 2a	 push	 711573504		; 2a69c000H
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 __alldiv
  0003c	8b c8		 mov	 ecx, eax
  0003e	e8 00 00 00 00	 call	 __ltod3
  00043	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  0004b	dd 85 2c ff ff
	ff		 fld	 QWORD PTR tv89[ebp]

; 110  : 	}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?GetTotalDays@TimeSpan@XNA@@QAENXZ ENDP			; XNA::TimeSpan::GetTotalDays
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetTicks@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTicks@TimeSpan@XNA@@QAE_JXZ PROC			; XNA::TimeSpan::GetTicks, COMDAT
; _this$ = ecx

; 103  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 		return this->ticks.count();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count

; 105  : 	}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?GetTicks@TimeSpan@XNA@@QAE_JXZ ENDP			; XNA::TimeSpan::GetTicks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetSeconds@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
?GetSeconds@TimeSpan@XNA@@QAE_JXZ PROC			; XNA::TimeSpan::GetSeconds, COMDAT
; _this$ = ecx

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return duration_cast<seconds>(this->ticks).count();

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,10000000> >
  00033	83 c4 08	 add	 esp, 8
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count

; 100  : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?GetSeconds@TimeSpan@XNA@@QAE_JXZ ENDP			; XNA::TimeSpan::GetSeconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetMinutes@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?GetMinutes@TimeSpan@XNA@@QAE_JXZ PROC			; XNA::TimeSpan::GetMinutes, COMDAT
; _this$ = ecx

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return duration_cast<minutes>(this->ticks).count();

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0DM@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<60,1> >,__int64,std::ratio<1,10000000> >
  00033	83 c4 08	 add	 esp, 8
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?count@?$duration@HU?$ratio@$0DM@$00@std@@@chrono@std@@QBEHXZ ; std::chrono::duration<int,std::ratio<60,1> >::count
  0003d	99		 cdq

; 95   : 	}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?GetMinutes@TimeSpan@XNA@@QAE_JXZ ENDP			; XNA::TimeSpan::GetMinutes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetMilliseconds@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
?GetMilliseconds@TimeSpan@XNA@@QAE_JXZ PROC		; XNA::TimeSpan::GetMilliseconds, COMDAT
; _this$ = ecx

; 88   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 89   : 		return duration_cast<milliseconds>(this->ticks).count();

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000> >
  00033	83 c4 08	 add	 esp, 8
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count

; 90   : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?GetMilliseconds@TimeSpan@XNA@@QAE_JXZ ENDP		; XNA::TimeSpan::GetMilliseconds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetHours@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?GetHours@TimeSpan@XNA@@QAE_JXZ PROC			; XNA::TimeSpan::GetHours, COMDAT
; _this$ = ecx

; 83   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		return duration_cast<hours>(this->ticks).count();

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<3600,1> >,__int64,std::ratio<1,10000000> >
  00033	83 c4 08	 add	 esp, 8
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ ; std::chrono::duration<int,std::ratio<3600,1> >::count
  0003d	99		 cdq

; 85   : 	}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?GetHours@TimeSpan@XNA@@QAE_JXZ ENDP			; XNA::TimeSpan::GetHours
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ?GetDays@TimeSpan@XNA@@QAE_JXZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?GetDays@TimeSpan@XNA@@QAE_JXZ PROC			; XNA::TimeSpan::GetDays, COMDAT
; _this$ = ecx

; 78   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 		return duration_cast<Days>(this->ticks).count();

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$duration_cast@V?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@HU?$ratio@$0OBA@$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<int,std::ratio<3600,1> >,__int64,std::ratio<1,10000000> >
  00033	83 c4 08	 add	 esp, 8
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?count@?$duration@HU?$ratio@$0OBA@$00@std@@@chrono@std@@QBEHXZ ; std::chrono::duration<int,std::ratio<3600,1> >::count
  0003d	99		 cdq

; 80   : 	}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?GetDays@TimeSpan@XNA@@QAE_JXZ ENDP			; XNA::TimeSpan::GetDays
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??GTimeSpan@XNA@@QAE?AV01@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GTimeSpan@XNA@@QAE?AV01@XZ PROC			; XNA::TimeSpan::operator-, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 		return TimeSpan(-(this->ticks));

  00023	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00036	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ; XNA::TimeSpan::TimeSpan
  0003b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 72   : 	}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??GTimeSpan@XNA@@QAE?AV01@XZ ENDP			; XNA::TimeSpan::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??NXNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??NXNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator<=, COMDAT

; 66   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 67   : 		return (lhs.ticks <= rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?N_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 68   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??NXNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator<=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??PXNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??PXNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator>=, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 63   : 		return (lhs.ticks >= rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?P_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator>=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 64   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??PXNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator>=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??9XNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??9XNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator!=, COMDAT

; 57   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 58   : 		return (lhs.ticks != rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?9_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator!=<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 59   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??9XNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??MXNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??MXNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator<, COMDAT

; 52   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 53   : 		return (lhs.ticks < rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?M_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 54   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??MXNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??OXNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??OXNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator>, COMDAT

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 48   : 		return (lhs.ticks > rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?O_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator><__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 49   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??OXNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??8XNA@@YA_NABVTimeSpan@0@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??8XNA@@YA_NABVTimeSpan@0@0@Z PROC			; XNA::operator==, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 43   : 		return (lhs.ticks == rhs.ticks);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$?8_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@0@Z ; std::chrono::operator==<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  0002b	83 c4 08	 add	 esp, 8

; 44   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??8XNA@@YA_NABVTimeSpan@0@0@Z ENDP			; XNA::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??GXNA@@YA?AVTimeSpan@0@ABV10@0@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??GXNA@@YA?AVTimeSpan@0@ABV10@0@Z PROC			; XNA::operator-, COMDAT

; 37   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 38   : 		return TimeSpan(lhs.ticks - rhs.ticks);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ; XNA::TimeSpan::TimeSpan
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 39   : 	}

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??GXNA@@YA?AVTimeSpan@0@ABV10@0@Z ENDP			; XNA::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??HXNA@@YA?AVTimeSpan@0@ABV10@0@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??HXNA@@YA?AVTimeSpan@0@ABV10@0@Z PROC			; XNA::operator+, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 33   : 		return TimeSpan(lhs.ticks + rhs.ticks);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00025	51		 push	 ecx
  00026	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$?H_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator+<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ; XNA::TimeSpan::TimeSpan
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 34   : 	}

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??HXNA@@YA?AVTimeSpan@0@ABV10@0@Z ENDP			; XNA::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??0TimeSpan@XNA@@QAE@_J0000@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
_d$ = 8							; size = 8
_h$ = 16						; size = 8
_m$ = 24						; size = 8
_s$ = 32						; size = 8
_millis$ = 40						; size = 8
??0TimeSpan@XNA@@QAE@_J0000@Z PROC			; XNA::TimeSpan::TimeSpan, COMDAT
; _this$ = ecx

; 27   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	68 c9 00 00 00	 push	 201			; 000000c9H
  00028	68 00 c0 69 2a	 push	 711573504		; 2a69c000H
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp+4]
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 __allmul
  0003a	8b f0		 mov	 esi, eax
  0003c	8b fa		 mov	 edi, edx
  0003e	6a 08		 push	 8
  00040	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  00045	8b 55 14	 mov	 edx, DWORD PTR _h$[ebp+4]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __allmul
  00052	03 f0		 add	 esi, eax
  00054	13 fa		 adc	 edi, edx
  00056	6a 00		 push	 0
  00058	68 00 46 c3 23	 push	 600000000		; 23c34600H
  0005d	8b 4d 1c	 mov	 ecx, DWORD PTR _m$[ebp+4]
  00060	51		 push	 ecx
  00061	8b 55 18	 mov	 edx, DWORD PTR _m$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 __allmul
  0006a	03 f0		 add	 esi, eax
  0006c	13 fa		 adc	 edi, edx
  0006e	6a 00		 push	 0
  00070	68 80 96 98 00	 push	 10000000		; 00989680H
  00075	8b 45 24	 mov	 eax, DWORD PTR _s$[ebp+4]
  00078	50		 push	 eax
  00079	8b 4d 20	 mov	 ecx, DWORD PTR _s$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 __allmul
  00082	03 f0		 add	 esi, eax
  00084	13 fa		 adc	 edi, edx
  00086	6a 00		 push	 0
  00088	68 10 27 00 00	 push	 10000			; 00002710H
  0008d	8b 55 2c	 mov	 edx, DWORD PTR _millis$[ebp+4]
  00090	52		 push	 edx
  00091	8b 45 28	 mov	 eax, DWORD PTR _millis$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 __allmul
  0009a	03 f0		 add	 esi, eax
  0009c	13 fa		 adc	 edi, edx
  0009e	89 b5 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], esi
  000a4	89 bd 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edi
  000aa	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000b0	51		 push	 ecx
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  000b9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 28 00	 ret	 40			; 00000028H
??0TimeSpan@XNA@@QAE@_J0000@Z ENDP			; XNA::TimeSpan::TimeSpan
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??0TimeSpan@XNA@@QAE@_J000@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
_d$ = 8							; size = 8
_h$ = 16						; size = 8
_m$ = 24						; size = 8
_s$ = 32						; size = 8
??0TimeSpan@XNA@@QAE@_J000@Z PROC			; XNA::TimeSpan::TimeSpan, COMDAT
; _this$ = ecx

; 22   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	68 c9 00 00 00	 push	 201			; 000000c9H
  00028	68 00 c0 69 2a	 push	 711573504		; 2a69c000H
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp+4]
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 __allmul
  0003a	8b f0		 mov	 esi, eax
  0003c	8b fa		 mov	 edi, edx
  0003e	6a 08		 push	 8
  00040	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  00045	8b 55 14	 mov	 edx, DWORD PTR _h$[ebp+4]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __allmul
  00052	03 f0		 add	 esi, eax
  00054	13 fa		 adc	 edi, edx
  00056	6a 00		 push	 0
  00058	68 00 46 c3 23	 push	 600000000		; 23c34600H
  0005d	8b 4d 1c	 mov	 ecx, DWORD PTR _m$[ebp+4]
  00060	51		 push	 ecx
  00061	8b 55 18	 mov	 edx, DWORD PTR _m$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 __allmul
  0006a	03 f0		 add	 esi, eax
  0006c	13 fa		 adc	 edi, edx
  0006e	6a 00		 push	 0
  00070	68 80 96 98 00	 push	 10000000		; 00989680H
  00075	8b 45 24	 mov	 eax, DWORD PTR _s$[ebp+4]
  00078	50		 push	 eax
  00079	8b 4d 20	 mov	 ecx, DWORD PTR _s$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 __allmul
  00082	03 f0		 add	 esi, eax
  00084	13 fa		 adc	 edi, edx
  00086	89 b5 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], esi
  0008c	89 bd 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edi
  00092	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00098	52		 push	 edx
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 20 00	 ret	 32			; 00000020H
??0TimeSpan@XNA@@QAE@_J000@Z ENDP			; XNA::TimeSpan::TimeSpan
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??0TimeSpan@XNA@@QAE@_J00@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
_h$ = 8							; size = 8
_m$ = 16						; size = 8
_s$ = 24						; size = 8
??0TimeSpan@XNA@@QAE@_J00@Z PROC			; XNA::TimeSpan::TimeSpan, COMDAT
; _this$ = ecx

; 18   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	6a 08		 push	 8
  00025	68 00 68 c4 61	 push	 1640261632		; 61c46800H
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp+4]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 __allmul
  00037	8b f0		 mov	 esi, eax
  00039	8b fa		 mov	 edi, edx
  0003b	6a 00		 push	 0
  0003d	68 00 46 c3 23	 push	 600000000		; 23c34600H
  00042	8b 55 14	 mov	 edx, DWORD PTR _m$[ebp+4]
  00045	52		 push	 edx
  00046	8b 45 10	 mov	 eax, DWORD PTR _m$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __allmul
  0004f	03 f0		 add	 esi, eax
  00051	13 fa		 adc	 edi, edx
  00053	6a 00		 push	 0
  00055	68 80 96 98 00	 push	 10000000		; 00989680H
  0005a	8b 4d 1c	 mov	 ecx, DWORD PTR _s$[ebp+4]
  0005d	51		 push	 ecx
  0005e	8b 55 18	 mov	 edx, DWORD PTR _s$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 __allmul
  00067	03 f0		 add	 esi, eax
  00069	13 fa		 adc	 edi, edx
  0006b	89 b5 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], esi
  00071	89 bd 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edi
  00077	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 18 00	 ret	 24			; 00000018H
??0TimeSpan@XNA@@QAE@_J00@Z ENDP			; XNA::TimeSpan::TimeSpan
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??0TimeSpan@XNA@@QAE@_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_t$ = 8							; size = 8
??0TimeSpan@XNA@@QAE@_J@Z PROC				; XNA::TimeSpan::TimeSpan, COMDAT
; _this$ = ecx

; 10   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8d 45 08	 lea	 eax, DWORD PTR _t$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
??0TimeSpan@XNA@@QAE@_J@Z ENDP				; XNA::TimeSpan::TimeSpan
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\sam\documents\visual studio 2013\projects\xna++\framework\src\timespan.cpp
;	COMDAT ??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
_t$ = 8							; size = 4
??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z PROC ; XNA::TimeSpan::TimeSpan, COMDAT
; _this$ = ecx

; 14   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  00026	e8 00 00 00 00	 call	 ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
  0002b	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00031	89 95 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00037	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
??0TimeSpan@XNA@@QAE@$$QAV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@@Z ENDP ; XNA::TimeSpan::TimeSpan
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=, COMDAT
; _this$ = ecx

; 173  : 		{	// subtract _Right from rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 		_MyRep -= _Right._MyRep;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	1b 41 04	 sbb	 eax, DWORD PTR [ecx+4]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 175  : 		return (*this);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 176  : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??Y?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Y?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator+=, COMDAT
; _this$ = ecx

; 167  : 		{	// add _Right to rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 168  : 		_MyRep += _Right._MyRep;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	03 11		 add	 edx, DWORD PTR [ecx]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	13 41 04	 adc	 eax, DWORD PTR [ecx+4]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 169  : 		return (*this);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 170  : 		}

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??Y?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-, COMDAT
; _this$ = ecx

; 140  : 		{	// get negated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 		return (_Myt(0 - _MyRep));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	33 c9		 xor	 ecx, ecx
  00028	2b 08		 sub	 ecx, DWORD PTR [eax]
  0002a	ba 00 00 00 00	 mov	 edx, 0
  0002f	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  00032	89 8d 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00038	89 95 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  0003e	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	e8 00 00 00 00	 call	 ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 142  : 		}

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??G?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE?AV012@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 132  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z
_TEXT	SEGMENT
$T1 = -276						; size = 4
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 8
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z PROC ; std::to_string, COMDAT

; 533  : 	{	// convert long long to string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 534  : 	char _Buf[2 * _MAX_INT_DIG];
; 535  : 
; 536  : 	_CSTD _TOSTRING(_Buf, _LLFMT "d", _Val);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp+4]
  00037	50		 push	 eax
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
  00041	6a 40		 push	 64			; 00000040H
  00043	8d 55 b8	 lea	 edx, DWORD PTR __Buf$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf_s
  0004d	83 c4 14	 add	 esp, 20			; 00000014H
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 537  : 	return (string(_Buf));

  00057	8d 45 b8	 lea	 eax, DWORD PTR __Buf$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00063	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00069	83 c9 01	 or	 ecx, 1
  0006c	89 8d ec fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00072	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 538  : 	}

  00075	52		 push	 edx
  00076	8b cd		 mov	 ecx, ebp
  00078	50		 push	 eax
  00079	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@to_string
  0007f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00084	58		 pop	 eax
  00085	5a		 pop	 edx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	33 cd		 xor	 ecx, ebp
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN7@to_string:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN6@to_string
$LN6@to_string:
  000ac	b8 ff ff ff	 DD	 -72			; ffffffb8H
  000b0	40 00 00 00	 DD	 64			; 00000040H
  000b4	00 00 00 00	 DD	 $LN5@to_string
$LN5@to_string:
  000b8	5f		 DB	 95			; 0000005fH
  000b9	42		 DB	 66			; 00000042H
  000ba	75		 DB	 117			; 00000075H
  000bb	66		 DB	 102			; 00000066H
  000bc	00		 DB	 0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_System_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

  0003d	e8 00 00 00 00	 call	 ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
  00042	50		 push	 eax
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00052	eb 17		 jmp	 SHORT $LN3@default_er

; 617  : 		else

  00054	eb 15		 jmp	 SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

  00056	e8 00 00 00 00	 call	 ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
  0005b	50		 push	 eax
  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00063	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00068	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Winerror_map@std@@YAPBDH@Z
  00039	83 c4 04	 add	 esp, 4
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	89 45 ec	 mov	 DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00046	83 7d ec 00	 cmp	 DWORD PTR __Name$[ebp], 0
  0004a	74 0b		 je	 SHORT $LN3@message
  0004c	8b 45 ec	 mov	 eax, DWORD PTR __Name$[ebp]
  0004f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00055	eb 0a		 jmp	 SHORT $LN4@message
$LN3@message:
  00057	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
  00061	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00067	51		 push	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00070	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00076	83 ca 01	 or	 edx, 1
  00079	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

  0002d	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  00031	75 23		 jne	 SHORT $LN2@message

; 586  : 			return ("iostream stream error");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  00038	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00040	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00046	83 c8 01	 or	 eax, 1
  00049	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00052	eb 24		 jmp	 SHORT $LN3@message

; 587  : 		else

  00054	eb 22		 jmp	 SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

  00056	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00066	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0006c	83 ca 01	 or	 edx, 1
  0006f	89 95 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
  00039	83 c4 04	 add	 esp, 4
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	89 45 ec	 mov	 DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00046	83 7d ec 00	 cmp	 DWORD PTR __Name$[ebp], 0
  0004a	74 0b		 je	 SHORT $LN3@message
  0004c	8b 45 ec	 mov	 eax, DWORD PTR __Name$[ebp]
  0004f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00055	eb 0a		 jmp	 SHORT $LN4@message
$LN3@message:
  00057	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
  00061	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00067	51		 push	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00070	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00076	83 ca 01	 or	 edx, 1
  00079	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0error_category@std@@QAE@XZ ; std::error_category::error_category
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0002b	50		 push	 eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 22		 je	 SHORT $LN3@operator
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  0004a	8b f0		 mov	 esi, eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004f	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00054	3b f0		 cmp	 esi, eax
  00056	75 0c		 jne	 SHORT $LN3@operator
  00058	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
  00062	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00064	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN4@operator:
  0006e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv78[ebp]

; 355  : 		}

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 339  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 334  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Cat$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 300  : 		}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 248  : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 243  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN1@scalar
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN1@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00029	75 0c		 jne	 SHORT $LN3@operator
  0002b	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00035	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00037	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00041	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv65[ebp]

; 178  : 		}

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  00026	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  0002b	50		 push	 eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  00034	0f b6 c0	 movzx	 eax, al
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $LN3@equivalent
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  0003e	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00043	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00046	75 0c		 jne	 SHORT $LN3@equivalent
  00048	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
  00052	eb 0a		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00054	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  0005e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv74[ebp]

; 393  : 	}

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Cond$[ebp]
  00026	50		 push	 eax
  00027	8b f4		 mov	 esi, esp
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0002c	51		 push	 ecx
  0002d	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00033	52		 push	 edx
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003f	ff d0		 call	 eax
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==

; 386  : 	}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 653  : 	return (_Error_objects<int>::_System_object);

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 643  : 	return (_Error_objects<int>::_Generic_object);

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 545  : 	{	// test iterator for non-singularity, const pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 546  : 	if (_First == 0)

  0001e	83 7d 08 00	 cmp	 DWORD PTR __First$[ebp], 0
  00022	75 1f		 jne	 SHORT $LN2@Debug_poin

; 547  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  00024	8b f4		 mov	 esi, esp
  00026	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Debug_poin:

; 548  : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xran:

; 2296 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 2291 : 		}

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

  00023	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	75 02		 jne	 SHORT $LN4@Tidy
  0002b	eb 79		 jmp	 SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00034	72 70		 jb	 SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 4d ec	 mov	 DWORD PTR __Ptr$3[ebp], ecx

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c0 04	 add	 eax, 4
  00045	50		 push	 eax
  00046	8d 8d 17 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

  0005c	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  00060	76 20		 jbe	 SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

  00062	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00065	50		 push	 eax
  00066	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$3[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00076	83 c2 04	 add	 edx, 4
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00088	83 c1 01	 add	 ecx, 1
  0008b	51		 push	 ecx
  0008c	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$3[ebp]
  0008f	52		 push	 edx
  00090	8d 85 23 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  0009f	8b c8		 mov	 ecx, eax
  000a1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 2285 : 		_Eos(_Newsize);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00023	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00027	74 20		 je	 SHORT $LN2@Inside
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00034	72 13		 jb	 SHORT $LN2@Inside
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00044	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00047	77 06		 ja	 SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

  00049	32 c0		 xor	 al, al
  0004b	eb 04		 jmp	 SHORT $LN4@Inside

; 2260 : 		else

  0004d	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

  0004f	b0 01		 mov	 al, 1
$LN4@Inside:

; 2262 : 		}

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0002e	73 08		 jae	 SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003e	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  00041	73 15		 jae	 SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00056	eb 53		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00058	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	74 3b		 je	 SHORT $LN3@Grow
  00060	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  00064	73 35		 jae	 SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0006c	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0006f	73 0b		 jae	 SHORT $LN9@Grow
  00071	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00074	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], edx
  0007a	eb 0c		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00082	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
$LN10@Grow:
  00088	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  0008e	52		 push	 edx
  0008f	6a 01		 push	 1
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00099	eb 10		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

  0009b	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0009f	75 0a		 jne	 SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

  000a1	6a 00		 push	 0
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

  000ab	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000af	76 0c		 jbe	 SHORT $LN11@Grow
  000b1	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
  000bb	eb 0a		 jmp	 SHORT $LN12@Grow
$LN11@Grow:
  000bd	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN12@Grow:
  000c7	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00023	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00030	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00033	8d 95 2f ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00039	52		 push	 edx
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00042	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0004b	83 c4 08	 add	 esp, 8

; 2238 : 		}

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -292						; size = 4
tv203 = -292						; size = 4
tv204 = -288						; size = 4
tv202 = -288						; size = 4
$T2 = -277						; size = 1
$T3 = -265						; size = 1
$T4 = -253						; size = 1
__Ptr$ = -52						; size = 4
__Newres$ = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00022	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	59		 pop	 ecx
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00043	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00046	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00049	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0004c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0004f	89 45 d8	 mov	 DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

  00052	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0005a	3b 45 d8	 cmp	 eax, DWORD PTR __Newres$[ebp]
  0005d	73 08		 jae	 SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

  0005f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00062	89 45 d8	 mov	 DWORD PTR __Newres$[ebp], eax
  00065	eb 52		 jmp	 SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00067	8b 45 d8	 mov	 eax, DWORD PTR __Newres$[ebp]
  0006a	33 d2		 xor	 edx, edx
  0006c	b9 03 00 00 00	 mov	 ecx, 3
  00071	f7 f1		 div	 ecx
  00073	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00076	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00079	d1 e9		 shr	 ecx, 1
  0007b	3b c8		 cmp	 ecx, eax
  0007d	77 02		 ja	 SHORT $LN7@Copy
  0007f	eb 38		 jmp	 SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00081	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00087	d1 ee		 shr	 esi, 1
  00089	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00091	2b c6		 sub	 eax, esi
  00093	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00099	77 13		 ja	 SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

  0009b	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000a1	d1 e9		 shr	 ecx, 1
  000a3	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  000a9	89 4d d8	 mov	 DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

  000ac	eb 0b		 jmp	 SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

  000ae	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000b6	89 45 d8	 mov	 DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

  000b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  000c0	8d 85 eb fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  000cf	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv202[ebp], eax
  000d5	8b 4d d8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  000d8	83 c1 01	 add	 ecx, 1
  000db	51		 push	 ecx
  000dc	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv202[ebp]
  000e2	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000e7	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv203[ebp], eax
  000ed	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv203[ebp]
  000f3	89 55 cc	 mov	 DWORD PTR __Ptr$[ebp], edx
  000f6	eb 76		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

  000f8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000fb	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000fe	89 45 d8	 mov	 DWORD PTR __Newres$[ebp], eax

; 2218 : 			_TRY_BEGIN

  00101	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00105	8d 85 f7 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00114	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv204[ebp], eax
  0011a	8b 4d d8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  0011d	83 c1 01	 add	 ecx, 1
  00120	51		 push	 ecx
  00121	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv204[ebp]
  00127	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  0012c	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  00132	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv205[ebp]
  00138	89 55 cc	 mov	 DWORD PTR __Ptr$[ebp], edx
  0013b	eb 1b		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

  0013d	6a 00		 push	 0
  0013f	6a 01		 push	 1
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

  00149	6a 00		 push	 0
  0014b	6a 00		 push	 0
  0014d	e8 00 00 00 00	 call	 __CxxThrowException@8

; 2223 : 			_CATCH_END

  00152	b8 00 00 00 00	 mov	 eax, $LN17@Copy
  00157	c3		 ret	 0
$LN14@Copy:
  00158	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0015f	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  00161	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

  00168	b8 00 00 00 00	 mov	 eax, $LN19@Copy
  0016d	c3		 ret	 0
$LN12@Copy:
  0016e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00175	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  00177	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

  0017e	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  00182	76 19		 jbe	 SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

  00184	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00190	50		 push	 eax
  00191	8b 4d cc	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

  0019d	6a 00		 push	 0
  0019f	6a 01		 push	 1
  001a1	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

  001a9	8d 45 cc	 lea	 eax, DWORD PTR __Ptr$[ebp]
  001ac	50		 push	 eax
  001ad	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	83 c1 04	 add	 ecx, 4
  001b3	51		 push	 ecx
  001b4	8d 95 03 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001ba	52		 push	 edx
  001bb	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

  001ca	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	8b 4d d8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  001d0	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2232 : 		_Eos(_Oldlen);

  001d3	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  001d6	50		 push	 eax
  001d7	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001da	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

  001df	52		 push	 edx
  001e0	8b cd		 mov	 ecx, ebp
  001e2	50		 push	 eax
  001e3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@Copy
  001e9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ee	58		 pop	 eax
  001ef	5a		 pop	 edx
  001f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fa	59		 pop	 ecx
  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00201	33 cd		 xor	 ecx, ebp
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  0020e	3b ec		 cmp	 ebp, esp
  00210	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c2 08 00	 ret	 8
  0021b	90		 npad	 1
$LN23@Copy:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN22@Copy
$LN22@Copy:
  00224	cc ff ff ff	 DD	 -52			; ffffffccH
  00228	04 00 00 00	 DD	 4
  0022c	00 00 00 00	 DD	 $LN20@Copy
$LN20@Copy:
  00230	5f		 DB	 95			; 0000005fH
  00231	50		 DB	 80			; 00000050H
  00232	74		 DB	 116			; 00000074H
  00233	72		 DB	 114			; 00000072H
  00234	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a d8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-296]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

  00023	8d 85 23 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
  00039	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

  0003c	83 7d ec 01	 cmp	 DWORD PTR __Num$[ebp], 1
  00040	77 0c		 ja	 SHORT $LN3@max_size
  00042	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
  0004c	eb 0c		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00051	83 e8 01	 sub	 eax, 1
  00054	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
$LN4@max_size:
  0005a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]

; 1761 : 		}

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1755 : 		}

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0002c	73 08		 jae	 SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  0003f	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00042	77 0e		 ja	 SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00044	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00050	eb 46		 jmp	 SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

  00052	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00056	76 40		 jbe	 SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00060	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00063	89 45 ec	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006c	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  0006f	89 4d e0	 mov	 DWORD PTR __Newsize$1[ebp], ecx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00072	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  00075	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00078	50		 push	 eax
  00079	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  0007c	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$2[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1352 : 			_Eos(_Newsize);

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Newsize$1[ebp]
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0002c	73 08		 jae	 SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

  00036	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);

  00023	68 90 04 00 00	 push	 1168			; 00000490H
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@JPIFMGNP@?$AAb?$AA?3?$AA?2?$AAv?$AAs?$AA2?$AA0?$AA1?$AA3?$AA?2?$AAv?$AAc?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAx?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
  0002d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00039	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)

  00023	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00027	74 16		 je	 SHORT $LN3@assign

; 1151 : 			_DEBUG_POINTER(_Ptr);

  00029	68 7f 04 00 00	 push	 1151			; 0000047fH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@JPIFMGNP@?$AAb?$AA?3?$AA?2?$AAv?$AAs?$AA2?$AA0?$AA1?$AA3?$AA?2?$AAv?$AAc?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAx?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
  00033	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@assign:

; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

  0003f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  0004b	0f b6 c8	 movzx	 ecx, al
  0004e	85 c9		 test	 ecx, ecx
  00050	74 20		 je	 SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

  00052	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00061	2b c8		 sub	 ecx, eax
  00063	51		 push	 ecx
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	52		 push	 edx
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00070	eb 3d		 jmp	 SHORT $LN4@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

  00072	6a 00		 push	 0
  00074	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00080	0f b6 c8	 movzx	 ecx, al
  00083	85 c9		 test	 ecx, ecx
  00085	74 25		 je	 SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00087	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0008e	51		 push	 ecx
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1161 : 			_Eos(_Count);

  000a0	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1164 : 		}

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00026	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  0002e	73 08		 jae	 SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003b	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00040	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

  00046	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	3b 45 ec	 cmp	 eax, DWORD PTR __Num$[ebp]
  0004c	73 06		 jae	 SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

  0004e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00051	89 45 ec	 mov	 DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  0005a	75 1f		 jne	 SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  0005f	03 45 ec	 add	 eax, DWORD PTR __Num$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0006e	51		 push	 ecx
  0006f	6a 00		 push	 0
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00079	eb 42		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

  0007b	6a 00		 push	 0
  0007d	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00080	50		 push	 eax
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	85 c9		 test	 ecx, ecx
  0008e	74 2d		 je	 SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

  00090	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0009c	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1142 : 			_Eos(_Num);

  000b1	8b 45 ec	 mov	 eax, DWORD PTR __Num$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00021	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8d 8d 23 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00048	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

  00069	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 672  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;

  0002d	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 675  : 		this->_Orphan_all();

  00035	8b f4		 mov	 esi, esp
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 676  : 		_Alproxy.destroy(this->_Myproxy);

  00047	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00050	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00055	6a 01		 push	 1
  00057	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	51		 push	 ecx
  0005d	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00060	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 678  : 		this->_Myproxy = 0;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 679  : 		}

  0006e	52		 push	 edx
  0006f	8b cd		 mov	 ecx, ebp
  00071	50		 push	 eax
  00072	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00078	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007d	58		 pop	 eax
  0007e	5a		 pop	 edx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
  0009d	8d 49 00	 npad	 3
$LN5@Free_proxy:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  000a8	eb ff ff ff	 DD	 -21			; ffffffebH
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	41		 DB	 65			; 00000041H
  000b6	6c		 DB	 108			; 0000006cH
  000b7	70		 DB	 112			; 00000070H
  000b8	72		 DB	 114			; 00000072H
  000b9	6f		 DB	 111			; 0000006fH
  000ba	78		 DB	 120			; 00000078H
  000bb	79		 DB	 121			; 00000079H
  000bc	00		 DB	 0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -232						; size = 8
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 663  : 		{	// construct proxy from _Alval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;

  0002d	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 666  : 		this->_Myproxy = _Alproxy.allocate(1);

  00035	6a 01		 push	 1
  00037	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0003a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 01		 mov	 DWORD PTR [ecx], eax

; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

  00044	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004a	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  0004f	50		 push	 eax
  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	8d 4d eb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00059	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 668  : 		this->_Myproxy->_Mycont = this;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00066	89 11		 mov	 DWORD PTR [ecx], edx

; 669  : 		}

  00068	52		 push	 edx
  00069	8b cd		 mov	 ecx, ebp
  0006b	50		 push	 eax
  0006c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00072	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00077	58		 pop	 eax
  00078	5a		 pop	 edx
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
  00097	90		 npad	 1
$LN5@Alloc_prox:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000a0	eb ff ff ff	 DD	 -21			; ffffffebH
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000ac	5f		 DB	 95			; 0000005fH
  000ad	41		 DB	 65			; 00000041H
  000ae	6c		 DB	 108			; 0000006cH
  000af	70		 DB	 112			; 00000070H
  000b0	72		 DB	 114			; 00000072H
  000b1	6f		 DB	 111			; 0000006fH
  000b2	78		 DB	 120			; 00000078H
  000b3	79		 DB	 121			; 00000079H
  000b4	00		 DB	 0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 649  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 650  : 		_Free_proxy();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 651  : 		}

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 643  : 	_String_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 646  : 		}

  00059	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00060	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b f4		 mov	 esi, esp
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 521  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0002a	72 17		 jb	 SHORT $LN3@Myptr
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 0c		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 514  : 		}

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b f4		 mov	 esi, esp
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 495  : 		_Myres = 0;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 496  : 		}

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  0002c	83 c4 04	 add	 esp, 4

; 885  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

  00023	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 848  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>

; 802  : 		}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 735  : 		return (_Al.max_size());

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 736  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00023	83 c8 ff	 or	 eax, -1

; 613  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00023	6a 00		 push	 0
  00025	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  0002e	83 c4 08	 add	 esp, 8

; 579  : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	83 c4 04	 add	 esp, 4

; 574  : 		}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	33 c0		 xor	 eax, eax
  00020	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 69   : 		}

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	33 c0		 xor	 eax, eax
  00020	88 85 3b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 564  : 		_Left = _Right;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	8a 11		 mov	 dl, BYTE PTR [ecx]
  00026	88 10		 mov	 BYTE PTR [eax], dl

; 565  : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@move
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 24		 jmp	 SHORT $LN4@move
$LN3@move:
  0002f	8b f4		 mov	 esi, esp
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@move:
  00053	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 554  : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001e	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	75 0b		 jne	 SHORT $LN3@copy
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 1a		 jmp	 SHORT $LN4@copy
$LN3@copy:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _memcpy
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@copy:
  00049	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 531  : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00024	85 c9		 test	 ecx, ecx
  00026	75 0c		 jne	 SHORT $LN3@length
  00028	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00032	eb 12		 jmp	 SHORT $LN4@length
$LN3@length:
  00034	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _strlen
  0003d	83 c4 04	 add	 esp, 4
  00040	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN4@length:
  00046	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]

; 524  : 		}

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 65   : 	}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   : 	return (_Where);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File b:\vs2013\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 557  :     return _hypot(_X, _Y);

  0001e	8b f4		 mov	 esi, esp
  00020	83 ec 08	 sub	 esp, 8
  00023	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR __Y$[ebp]
  00028	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  00035	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___hypot
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 558  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_hypot	ENDP
_TEXT	ENDS
END
